import type { AutomergeUrl } from "@automerge/automerge-repo";
import { next as Automerge, type ActorId } from "@automerge/automerge";

export interface ProfileDoc {
  name: string;

  channels: AutomergeUrl[];
}

export const ProfileDoc = Object.freeze({
  make: ({ name }: { name: string }): ProfileDoc => ({
    name,
    channels: [],
  }),

  addChannel: (profile: ProfileDoc, channel: AutomergeUrl) => {
    profile.channels.push(channel);
  },
});

export interface ChannelDoc {
  name: string;

  rootPage: AutomergeUrl;
}

export const ChannelDoc = Object.freeze({
  make: ({
    name,
    rootPage,
  }: {
    name: string;
    rootPage: AutomergeUrl;
  }): ChannelDoc => ({
    name,
    rootPage,
  }),
});

export interface PageDoc {
  /**
   * Links to sub-pages or messages.
   * The keys are the url to a subpage or message.
   */
  nodes: Record<
    AutomergeUrl,
    {
      type: "page" | "message";

      /**
       * Range of timestamps for the messages in the subpage.
       * If this is a message entry, the range is the timestamp of the message.
       */
      range: GrowRange;
    }
  >;
}

export const PageDoc = Object.freeze({
  make: (): PageDoc => ({
    nodes: {},
  }),

  getEntries: (page: PageDoc): PageEntry[] => {
    return Object.entries(page.nodes).map(([url, node]) => [
      url as AutomergeUrl,
      node,
    ]);
  },

  getEntryCount: (page: PageDoc): number => {
    return Object.keys(page.nodes).length;
  },

  getTimestampRange: (page: PageDoc): { from: number; to: number } => {
    return {
      from: Math.min(
        ...Object.values(page.nodes).map((node) => node.range.entires.from)
      ),
      to: Math.max(
        ...Object.values(page.nodes).map((node) => node.range.entires.to)
      ),
    };
  },

  updateRangeFor: (
    page: PageDoc,
    url: AutomergeUrl,
    actorId: ActorId,
    from: number,
    to: number
  ) => {
    GrowRange.add(page.nodes[url].range, actorId, from);
    GrowRange.add(page.nodes[url].range, actorId, to);
  },

  addMessage: (page: PageDoc, url: AutomergeUrl, ts: number) => {
    page.nodes[url] = {
      type: "message",
      range: GrowRange.makeFrom(ts, ts),
    };
  },

  addPage: (page: PageDoc, url: AutomergeUrl) => {
    page.nodes[url] = {
      type: "page",
      range: GrowRange.make(),
    };
  },
});

export type PageEntry = readonly [AutomergeUrl, PageDoc["nodes"][AutomergeUrl]];

/**
 * A register that tracks the min and max values of a set of numbers.
 */
export interface GrowRange {
  /**
   * The entries are unique ids generated by actors.
   * On write, the actor writes a new entry with a unique id.
   * The actor is free to remove any entries that are between min and max values.
   */
  entires: {
    [id: string]: number;
  };
}

export const GrowRange = Object.freeze({
  make: (): GrowRange => ({
    entires: {},
  }),

  makeFrom: (from: number, to: number): GrowRange => ({
    entires: {
      from,
      to,
    },
  }),

  add: (growRange: GrowRange, actorId: ActorId, value: number) => {
    const keys = Object.keys(growRange.entires);
    const newId = actorId + keys.length;
    growRange.entires[newId] = value;

    const min = GrowRange.getMin(growRange);
    const max = GrowRange.getMax(growRange);

    for (const key of Object.keys(growRange.entires)) {
      if (growRange.entires[key] > min && growRange.entires[key] < max) {
        delete growRange.entires[key];
      }
    }

    return newId;
  },

  getMin: (growRange: GrowRange) => {
    return Math.min(...Object.values(growRange.entires));
  },

  getMax: (growRange: GrowRange) => {
    return Math.max(...Object.values(growRange.entires));
  },
});

export interface MessageDoc {
  author: string;
  timestamp: number;
  message: string;
}

export const MessageDoc = Object.freeze({
  make: ({
    author,
    timestamp,
    message,
  }: {
    author: string;
    timestamp: number;
    message: string;
  }): MessageDoc => ({
    author,
    timestamp,
    message,
  }),
});
